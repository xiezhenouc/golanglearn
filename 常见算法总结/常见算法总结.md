# 常见算法总结

## 1 快速排序-哨兵选择，自顶向下递归
```golang
package main

import (
	"fmt"
)

func index(a []int, low int, high int) int {
	// 1 选第一个作为哨兵
	tmp := a[low]

	for low < high {
		// 2 从右往左
		for low < high && a[high] >= tmp {
			high--
		}
		a[low] = a[high]
		// 3 从左往右
		for low < high && a[low] <= tmp {
			low++
		}
		a[high] = a[low]
	}

	// 4 重复的位置重新赋值
	a[low] = tmp

	return low
}

func qsort(a []int, low int, high int) {
	if low >= high {
		return
	}

	mid := index(a, low, high)
	qsort(a, low, mid-1)
	qsort(a, mid+1, high)
}
func main() {
	a := []int{5,3,4,2,1}

	fmt.Println(a)

	qsort(a, 0, len(a)-1)

	fmt.Println(a)
}
```

## 2 单链表原地反转-记住前后指针
```golang
package main

import (
	"fmt"
)

type node struct {
	val int
	next *node
}

// a->b...->x
func reverse(head *node) *node {
	// 空节点直接返回
	if head == nil || head.next == nil {
		return head
	}
	
	// 前一个，默认nil
	var pre *node 
	// 后一个，默认head的下一个
	var post *node
	post = head.next

	for post != nil {
		// 当前节点next指针赋值
		head.next = pre

		// 记住前一个
		pre = head
		// 前进一个
		head = post
		// 记住后一个
		post = head.next
	}

	// 最后一个节点的next指针赋值
	if post == nil && head != nil {
		head.next = pre
	}

	return head
}

func main() {
	node3 := &node{
		val:3,
		next:nil,
	}
	node2 := &node{
		val:2,
		next:node3,
	}
	node1 := &node{
		val:1,
		next:node2,
	}

	p := node1
	for p != nil {
		fmt.Println(p.val)
		p = p.next
	}

	x := reverse(node1)
	p = x
	for p != nil {
		fmt.Println(p.val)
		p = p.next
	}
}
```

## 3 合并两个有序单向链表-双指针法

```golang
package main

import (
	"fmt"
)

type node struct {
	val int
	next *node
}

func mergeList(p1 *node, p2 *node) *node {
	if p1 == nil {
		return p2
	}
	if p2 == nil {
		return p1
	}

	head := &node{
		val:-1,
		next:nil,	
	}
	p := head

	h1 := p1
	h2 := p2

	for h1 != nil && h2 != nil {
		if h1.val < h2.val {
			head.next = h1
			h1 = h1.next
		} else {
			head.next = h2
			h2 = h2.next
		}
		head = head.next
	}
	for h1 != nil {
		head.next = h1
		h1 = h1.next
		head = head.next
	}

	for h2 != nil {
		head.next = h2
		h2 = h2.next
		head = head.next
	}

	return p.next
}	

func main() {
	node3 := &node{
		val:9,
		next:nil,
	}
	node2 := &node{
		val:7,
		next:node3,
	}
	node1 := &node{
		val:4,
		next:node2,
	}

	node02 := &node{
		val:8,
		next:nil,
	}
	node01 := &node{
		val:2,
		next:node02,
	}


	ret := mergeList(node1, node01)

	for ret != nil {
		fmt.Println(ret.val)
		ret = ret.next
	}
}
```

## 4 判断单向链表是否是回文数-快慢指针找中点，后半段原地反转

```golang
package main

import (
	"fmt"
)

type node struct {
	val int
	next *node
}

func reverse(h *node) *node {
	if h == nil || h.next == nil {
		return h
	}

	var pre *node
	var after *node
	p := h
	for p != nil {
		after = p.next
		p.next = pre
		pre = p

		p = after
	}

	return pre
}

func isHuiwen(h *node) bool {
	if h == nil || h.next == nil {
		return true
	}

	var newhead *node
	p1 := h
	p2 := h

	for p1 != nil && p2 != nil && p2.next != nil {
		p1 = p1.next
		p2 = p2.next.next
	}

	// 偶数
	if p2 == nil {
		newhead = p1 
	} else {
		newhead = p1.next
	}

	hnew := reverse(newhead)

	for h != nil && hnew != nil {
		if h.val != hnew.val {
			return false
		}

		h = h.next
		hnew = hnew.next
	}

	return true
}	

func main() {
	node4 := &node{
		val:1,
		next:nil,
	}
	node3 := &node{
		val:2,
		next:node4,
	}
	node2 := &node{
		val:4,
		next:node3,
	}
	node1 := &node{
		val:1,
		next:node2,
	}
	ret := node1
	for ret != nil {
		fmt.Println(ret.val)
		ret = ret.next
	}

	fmt.Println(isHuiwen(node1))
	ret = node1
	//ret := reverse(node1)
	for ret != nil {
		fmt.Println(ret.val)
		ret = ret.next
	}
}
```