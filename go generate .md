# go generate 
>go generate命令是go 1.4版本里面新添加的一个命令，当运行go generate时，它将扫描与当前包相关的源代码文件，找出所有包含"//go:generate"的特殊注释，提取并执行该特殊注释后面的命令，命令为可执行程序，形同shell下面执行。

>有几点需要注意：
该特殊注释必须在.go源码文件中。

>每个源码文件可以包含多个generate特殊注释时。

>显示运行go generate命令时，才会执行特殊注释后面的命令。

>命令串行执行的，如果出错，就终止后面的执行。

>特殊注释必须以"//go:generate"开头，双斜线后面没有空格。

## 1 helloworld demo
>main.go

```
package main

import "fmt"

//go:generate echo hello
//go:generate go run main.go
//go:generate  echo file=$GOFILE pkg=$GOPACKAGE
func main() {
	fmt.Println("main func")
}
```

>执行`go generate`

```
$ go generate main.go 
hello
main func
file=main.go pkg=main
```

>我理解是类似执行shell，只不过我们现在只用了echo，下一个例子用的高科技一点

## 2 自动生成代码
>需要使用下面的包

```
$ go get golang.org/x/tools/cmd/stringer
```

>在$GOPATH下新建painkiller，新建painkiller.go

```
//go:generate stringer -type=Pill
package painkiller

type Pill int

const (
	Placebo Pill = iota
	Aspirin
	Ibuprofen
	Paracetamol
	Acetaminophen = Paracetamol
)
```

>执行`go generate`

>生成代码文件`pill_string.go`

```
// Code generated by "stringer -type=Pill"; DO NOT EDIT.

package painkiller

import "strconv"

const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"

var _Pill_index = [...]uint8{0, 7, 14, 23, 34}

func (i Pill) String() string {
	if i < 0 || i >= Pill(len(_Pill_index)-1) {
		return "Pill(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
```

>新建一个main.go的文件，代码如下

```
package main

import (
	"fmt"
	"painkiller"
)

func main() {
	fmt.Println(painkiller.Placebo)
	fmt.Println(painkiller.Aspirin)
	fmt.Println(painkiller.Ibuprofen)
	fmt.Println(painkiller.Paracetamol)
	fmt.Println(painkiller.Acetaminophen)
}
```

>结果

```
$ go run main.go
Placebo
Aspirin
Ibuprofen
Paracetamol
Paracetamol
```

>分析，可以通过自己实现的工具，让工具帮我们生成代码