#golang闭包使用

## 1 概念
>闭包的概念：是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。

>闭包的价值 : 闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。

>Go语言中的闭包同样也会引用到函数外的变量。闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在。

>总结：闭包并不是一门编程语言不可缺少的功能，但闭包的表现形式一般是以匿名函数的方式出现，就象上面说到的，能够动态灵活的创建以及传递，体现出函数式编程的特点。所以在一些场合，我们就多了一种编码方式的选择，适当的使用闭包可以使得我们的代码简洁高效。

>使用闭包的注意点:由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包

## 2 示例

### 2.1 用函数返回另外一个函数
```
package main

import "fmt"

func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    pos, neg := adder(), adder()
    for i := 0; i < 10; i++ {
        fmt.Println(
            pos(i),
            neg(-2*i),
        )
    }
}
```
```
//输出结果
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90
```
>adder()函数中的sum是被多个函数共享的，所以可以累加

### 2.2 
```
package main

import "fmt"

func main() {
	var flist []func()
	for i := 0; i < 3; i++ {
		flist = append(flist, func() {
			fmt.Println(i)
		})
	}

	for _, f := range flist {
		f()
	}
}
```
```
//输出结果
3
3
3
```
>变量i是被共享

### 2.3 
```
package main

import "fmt"

func main() {
    var flist []func()
    for i := 0; i < 3; i++ {

        i := i //给i变量重新赋值，
		 fmt.Println(&i)
        flist = append(flist, func() {
            fmt.Println(i)
        })
    }
    for _, f := range flist {
        f()
    }
}
```
```
//输出结果
0xc4200160b0
0xc4200160b8
0xc4200160d0
0
1
2
```
>可以看到每次执行的时候i地址是不同的，所以大家各自使用各自的i

