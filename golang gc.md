# golang gc 学习

## 1 GC的认识

### 1.1 什么是GC，有什么作用 
>GC garbage collection，即垃圾回收，是一种自动内存管理的机制

>当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请时复用，或者将其归还给操作系统。这种针对内存级别资源的自动回收过程，即为垃圾回收。负责垃圾回收的程序组件，就是垃圾回收器。

>垃圾回收器本身是一个 "简单即复杂" 的例子。
>一方面，程序员受益于GG，无需操心，也不再需要对内存进行手动的申请和释放操作，GC在程序运行时自动释放残留内存。
>另一方面，GC对程序员几乎不可见，仅在程序需要进行特殊优化的时候，通过提供可调控的api，对GC的运行时机、运行开销进行把控的时候才现身。

>通常，垃圾回收器的执行过程分为两个半独立的组件
>赋值器 : 本质上指用户态代码。对垃圾回收器而言，用户态的代码仅仅是在修改对象之间的引用关系，修改对象图（对象之间引用关系的有向图）
>回收器 : 负责执行垃圾回收的代码

### 1.2 根对象是什么
>根对象在垃圾回收的术语中又叫根集合，它是垃圾回收器在标记过程中最先检查的对象，主要包括
>1 全局变量。程序在编译期就能确定那些存在于程序整个生命周期的变量
>2 执行栈。每个goroutine都包含自己的执行栈，执行栈上包括栈上的变量和指向堆内存的指针
>3 寄存器。寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存。

### 1.3 常见的GC实现方式有哪些？golang的GC是如何实现的？
>GC算法按照存在形式 可以分为 追踪和引用计数 这两种形式的混合运行
>追踪式GC：从根对象出发，根据对象之间的引用关系，一步步推进直至扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go Java V8的实现均为追踪式GC。
>引用计数式GC：每个对象包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python Object-C的实现均为引用计数式GC。

>GC算法按照实现方式分为
>追踪式，分为多种不同的类型，比如
>标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。
>标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内存上。
>增量式：将标记和清扫的过程分批执行，每次执行很小的部分，从而增量的推进垃圾回收，从而达到近似实时、几乎无停顿的目的
>增量整理：在增量式的基础上，增加对对象的整理过程
>分代式：将对象根据存活时间长短进行分类。存活时间小于某个值的是年轻代，存活时间大于某个值的是老年代。永远不会参与回收的对象是老年代。分代假设：如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间。根据此假设进行回收。
>引用计数：根据对象的引用计数来进行回收，当引用计数归零时候立即回收

>对于go而言，目前使用的是 无分代 、 不整理、 并发（与用户代码并发执行）的三色标记清扫算法。原因如下
>1 对象整理的优势是解决内存碎片以及"允许"使用顺序内存分配器。但Go运行时的分配算法基于tcmalloc，基本上没有碎片问题。并且顺序内存分配器在多线程的场景下并不适用。Go使用的是基于tcmalloc的现代内存分配算法。对对象进行整理不会带来实质性的性能提升。
>2 分代Gc依赖分代假设。即GC将主要的目标放在新创建的对象上（存活时间短，倾向于被回收），而非频繁检查所有对象。但Go的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代GC回收的那些存活时间短的对象在go中是直接分配到栈上，当goroutine死亡后栈也会被直接回收，不需要gc的参与，进而分代假设没有带来直接的优势。并且Go的垃圾回收器与用户代码并发执行，使得STW的时间与对象的代际、对象的size没有关系。Go团队更关注于如何更好的让GC和用户代码并发执行（使用适当的cpu进行垃圾回收），而非减少停顿时间这一单一目标。

### 1.4 三色标记法是什么
>初期版本，标记清扫算法，所有标志位都是0，从根对象开始遍历，如果对象可达就标记为1，全部扫描完毕后，将不可达的对象清除，再次将标志位标记为0，方便下次使用。缺点是，GC期间需要STW，无法进行异步GC，因为在不同标记和清扫阶段0和1含义不同：标记阶段1可达，0不可达；清除阶段0代表可达。我的理解是无法保留已经做过的工作。
>后期版本，三色标记法，异步GC，将做过的工作保留。
>理解三色标记法的的关键是理解对象的三色抽象和波面推进。
>白色对象（可能死亡，未扫描)：未被回收器扫描到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色均为不可达对象（无法遍历到）。
>灰色对象（波面，正在扫描中）：正在被回收器扫描的对象。但回收器需要对其中一个或者多个指针进行扫描，因为还有可能指向白色对象。
>黑色对象（确认存活，已扫描过）：已经被会回收器访问完毕的对象。其中所有字段都已经被扫描，黑色对象的任何一个指针都不可能被指向白色对象。
>每一个对象这三种状态的变化实际上就是波面推进的过程。这个波面也是黑色和白色的边界，灰色对象组成这个波面。
>当垃圾回收开始时，只有白色对象。随着标记过程开始进行时，灰色对象开始出现（着色），这时候波面开始变大。当一个对象的所有子节点均完成扫描后，该节点被着色成黑色。当整个堆遍历完成时，只剩下黑色和白色对象，这时的黑色对象是可达对象，即存活，白色对象是不可达对象，即死亡。这个过程可以视为以灰色对象为波面，将波面不断推进，直到所有的可达的灰色对象都变为黑色对象的过程。

![三色标记](https://raw.githubusercontent.com/xiezhenouc/golanglearn/master/%E5%9B%BE%E7%89%87%E8%AF%B4%E6%98%8E/sanse.png)

>三色标记的优点和缺点：支持异步gc，但是最早标记的黑色可能目前已经是不可达了，有点延迟性。

### 1.5 STW是什么意思
>STW是stop the world的含义，垃圾回收过程中，为了保证实现的准确性、防止无止境的内存增长问题，不可避免的需要赋值器停止一段时间，赋值器停止操作对象图。

>在这个过程中，整个用户代码被停止或者放缓执行。STW越长，对用户代码的延迟影响就越大。早期Go STW时间长达几百毫秒，对时间敏感的实时通信造成很大影响。

```golang
package main

import (
	"runtime"
	"time"
)

func main() {
	go func() {
		for {
		}
	}()

	time.Sleep(time.Millisecond)
	runtime.GC()
	println("OK")
}
```
>上面这个程序在go1.14以前都无法打印出来OK，原因是STW得不到执行时间。启动的goroutine永远不会停止

### 1.6 如何观察go gc

#### 1.6.1 GODEBUG

```golang
// test.go
package main

func allocate() {
	_ = make([]byte, 1<<20) // 不停申请空间
}

func main() {
	for n := 1; n < 100000; n++ {
		allocate()
	}
}
```

```golang
go build test.go
GODEBUG=gctrace=1 ./test

gc 215 @0.162s 7%: 0.001+0.047+0.003 ms clock, 0.003+0.033/0/0.015+0.006 ms cpu, 4->4->0 MB, 5 MB goal, 2 P
scvg: 0 MB released
scvg: inuse: 1, idle: 62, sys: 63, released: 57, consumed: 6 (MB)

gc 216 @0.162s 7%: 0.001+0.51+0.004 ms clock, 0.003+0.023/0/0.022+0.008 ms cpu, 4->5->1 MB, 5 MB goal, 2 P
scvg: 0 MB released
scvg: inuse: 5, idle: 58, sys: 63, released: 57, consumed: 6 (MB)

gc 215      第215次gc
@0.162s     程序开始后的0.162s
7%          gc期间cpu占用率
0.001       标记开始时， STW 所花费的时间（wall clock）
0.047       标记过程中，并发标记所花费的时间（wall clock）
0.003       标记终止时， STW 所花费的时间（wall clock）
0.003       标记开始时， STW 所花费的时间（cpu time）
0.033       标记过程中，标记辅助所花费的时间（cpu time）
0           标记过程中，并发标记所花费的时间（cpu time）
0.015       标记过程中，GC 空闲的时间（cpu time）
0.006       标记终止时， STW 所花费的时间（cpu time）
4           标记开始时，堆的大小的实际值
4           标记结束时，堆的大小的实际值
0           标记结束时，标记为存活的对象大小
5           标记结束时，堆的大小的预测值
2           P 的数量

wall clock vs cpu time
wall clock : 开始执行到结束需要的时间，包括本程序和其他程序的时间和
cpu time : 特定程序需要的时间
充分使用多核    wall clock < cpu time
串行          wall clock = cpu time
多核优势不明显  wall clock > cpu time 

scvg 向操作系统归还多余内存
gc 215 @0.162s 7%: 0.001+0.047+0.003 ms clock, 0.003+0.033/0/0.015+0.006 ms cpu, 4->4->0 MB, 5 MB goal, 2 P
scvg: 0 MB released
scvg: inuse: 1, idle: 62, sys: 63, released: 57, consumed: 6 (MB)

0 MB released       向操作系统归还了 0MB 内存
inuse: 1            已经分配给用户代码、正在使用的总内存大小 (MB)
idle: 62            空闲以及等待归还给操作系统的总内存大小（MB）
sys: 63             通知操作系统中保留的内存大小（MB）
released: 57        已经归还给操作系统的的内存大小
consumed: 6 (MB)    已经从操作系统中申请的内存大小（MB)
```

#### 1.6.2 go tool trace
```golang
package main

import (
    "os"
    "runtime/trace"
)

func main() {
	f, _ := os.Create("trace.out")
	defer f.Close()
	trace.Start(f)
	defer trace.Stop()
	test()
}

func allocate() {
	_ = make([]byte, 1<<20)
}

func test() {
	for n := 1; n < 1000; n++ {
		allocate()
	}
}
```
```golang
$ go run test.go
$ go tool trace trace.out
2020/04/28 16:05:30 Parsing trace...
2020/04/28 16:05:30 Splitting trace...
2020/04/28 16:05:30 Opening browser. Trace viewer is listening on http://127.0.0.1:63596
```

![trace](https://raw.githubusercontent.com/xiezhenouc/golanglearn/master/%E5%9B%BE%E7%89%87%E8%AF%B4%E6%98%8E/trace.png)

![tracedetails](https://raw.githubusercontent.com/xiezhenouc/golanglearn/master/%E5%9B%BE%E7%89%87%E8%AF%B4%E6%98%8E/tracedetails.png)

#### 1.6.3 debug.ReadGCStats runtime.ReadMemStats 
>查看官方文档即可

### 1.7 有了GC，为什么还会有内存泄露

### 1.8 并发标记清除的难点是什么

### 1.9 什么是写屏障、混合写屏障，如何实现

## 2 GC的实现细节

### 2.1 go语言的GC流程是什么

### 2.2 触发gc的时机是什么

### 2.3 如果内存分配的速度超过了标记清除的速度怎么办

## 3 GC 优化

### 3.1 GC关注的指标有哪些

### 3.2 go gc如何调优

### 3.3 go 垃圾回收器有哪些相关的api 作用是什么

## 4 gc的历史和演进

### 4.1 go历史各个版本对gc的改进

### 4.2 go gc 在演化过程中有过哪些设计？为什么没有采用

### 4.3 目前提供GC的语言和不提供GC的语言有哪些？GC和NoGC的优缺点是什么？

### 4.4 Go对比Java V8 GC性能如何

### 4.5 目前Go语言的GC还存在哪些问题

## 5 总结

